<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>疯狂的暑期动物园</title>
    <url>/2023/06/30/hello-world/</url>
    <content><![CDATA[<p>是的，大家都知道动物园很疯狂，尤其是暑期的动物园，但是，究竟疯狂在哪一方面呢？点击<a href="https://www.baidu.com">链接</a>，你会知道这一些 :）</p>
<h2 id="彻底疯狂-并且测试markdown数学公式！">彻底疯狂,并且测试markdown数学公式！</h2>
<p>$\left(\frac{x}{y}\right)$</p>
<h2 id="彻底疯狂，并且测试markdown图片！">彻底疯狂，并且测试markdown图片！</h2>
<!-- ![图片](/images/avatar.jpeg) -->
<!-- ![图片](avatar.jpeg#pic_center) -->
<div align = "">
    <img src = "/images/avatar.jpeg" width = "30%j">    
    <!-- <img src = "avatar.jpeg" width = "30%j">    
    <img src = "avatar.jpeg" width = "30%j"> -->
</div>]]></content>
  </entry>
  <entry>
    <title>菜猫喝水</title>
    <url>/2023/07/02/test/</url>
    <content><![CDATA[<h2 id="【TiTle】">【TiTle】</h2>
<p>身为全电大最聪明的猫，菜猫他有 $n$ 个不同水杯，为了方便喝水，菜猫给第 $i$ 号水杯里面盛上i毫升水。</p>
<h2 id="【Content】">【Content】</h2>
<p>有一天，猫口渴了。他决定喝一些水来解渴。因为活得太久，喝水在猫看来也应该是一种艺术，不同的水杯里的水一起喝可口程度不同。所以他决定在他的 $n$ 个水杯中挑出可口度最大的 $k$ 个水杯来喝水。这 $k$ 个水杯的可口度是他们的盛水量的最大公约数。</p>
<h2 id="【Standard-Input】">【Standard Input】</h2>
<p>两个空格分开的正整数 $n$ 和 $k$。</p>
<h2 id="【Standard-Output】">【Standard Output】</h2>
<p>一个整数，为最大的可口度。</p>
<p>输入样例</p>
<blockquote>
<p>4 2</p>
</blockquote>
<p>输出样例</p>
<blockquote>
<p>2</p>
</blockquote>
<h2 id="【样例解释】">【样例解释】</h2>
<p>菜猫一共有 $4$ 个杯子，里面分别装了 $1$ mL，$2$ mL，$3$ mL 和 $4$ mL 水，现在要挑出两杯水，使得这些水的毫升数的最大公约数最大。可以挑选$2$ mL和 $4$ mL，这样最大公约数为 $2$，最为可口。但假如挑选的是 $1$ mL 和 $3$ mL，最大公约数仅为 $1$，不是很可口。所以可口度最大为 $2$.<br>
对于 100% 的数据，$k$，$n$ $\leq$ $2\cdot 10^9$</p>
<h2 id="【示例代码】">【示例代码】</h2>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
const int mo = 1e9+7,maxn = 12;
int n,col[3],cha[3] = &#123;0&#125;,id = 0,has[99][99],m,cnt = 0,tot1[999],tot2[999];
char a[maxn + 1],b[maxn + 1],t;
struct node&#123;
    long long v[80][80];
&#125;nil,ans,f;
node operator * (node a,node b)&#123;
    node c = nil;
    long long t ;
    for (int i = 0 ; i &lt;= id; ++i)
        for (int j = 0 ; j &lt;= id ; ++j)&#123;
            t = 0;
            for (int k = 0 ; k &lt;= id ; ++k) t = (t + a.v[i][k] * b.v[k][j]) % mo;
            c.v[i][j] = t;
        &#125;
    return c;
&#125;
int main()&#123;
    scanf(&quot;%s%s&quot;,a,b);  n = strlen(a);
    for (int i = 0 ; i &lt; 3 ; ++i) scanf(&quot;%d&quot;,&amp;col[i]);
    scanf(&quot;%d&quot;,&amp;m);
    for (int i = 0 ; i &lt; n ; ++i)&#123;
        cha[(b[i] - a[i] + 3) % 3] ++;
        t = a[i];
        while (t != b[i])&#123;
            ++cnt; m -= col[t - 'a'];
            ++t;
            if (t &gt; 'c') t -= 3;
        &#125;
    &#125;
    if (m &lt; 0)&#123;puts(&quot;0&quot;); return 0;&#125;
    m = m / (col[0] + col[1] + col[2]) * 3 + cnt;
    
    for (int i = 0 ; i &lt;= n ; ++i)
        for (int j = 0 ; i + j &lt;= n ; ++j)&#123;
            has[i][j] = ++id;
            tot1[id] = i;
            tot2[id] = j;
        &#125;
    memset(nil.v,0,sizeof(nil.v));
    ans = f = nil;
    ans.v[ has[cha[1]][cha[2]] ][0] = 1;
    int x,y;
    for (int i = 1 ; i &lt;= id ; ++i)&#123;
        x = tot1[i]; y = tot2[i];
        if (n - x - y) f.v[i][has[x + 1][y]] = x + 1;
        if (x) f.v[i][has[x - 1][y + 1]] = y + 1;
        if (y) f.v[i][has[x][y - 1]] = n - x - y + 1;
    &#125;
    f.v[0][0] = 1; f.v[0][1] = 1;
    for (;m;m&gt;&gt;=1,f=f*f) if (m &amp;1) ans = f * ans;
    cout&lt;&lt;(ans.v[0][0] + ans.v[1][0]) % mo; 
    return 0;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>简单数论</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
        <tag>观察性质</tag>
      </tags>
  </entry>
</search>
